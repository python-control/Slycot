!    -*- f90 -*-
subroutine sb01bd(dico,n,m,np,alpha,a,lda,b,ldb,wr,wi,nfp,nap,nup,f,ldf,z,ldz,tol,dwork,ldwork,iwarn,info) ! in SB01BD.f
    character :: dico
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    integer required,check(np>=0 && np<=n),depend(n) :: np
    double precision :: alpha
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(np),depend(np) :: wr
    double precision intent(in,out,copy),dimension(np),depend(np) :: wi
    integer intent(out) :: nfp
    integer intent(out) :: nap
    integer intent(out) :: nup
    double precision intent(out),dimension(m,n) :: f
    integer intent(hide),depend(f) :: ldf=shape(f,0)
    double precision intent(out),dimension(n,n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    double precision :: tol = 0
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer :: ldwork = max(5*n,2*n+5*m)+1
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sb01bd
subroutine sb02md(dico,hinv,uplo,scal,sort,n,a,lda,g,ldg,q,ldq,rcond,wr,wi,s,lds,u,ldu,iwork,dwork,ldwork,bwork,info) ! in :slycot:SB02MD.f
	fortranname sb02md
	character :: dico
	character :: hinv='D'
	character :: uplo='U'
	character :: scal='N'
	character :: sort='S'
	integer check(n>0):: n
	double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,n),depend(n) :: g
	integer intent(hide),depend(g) :: ldg=shape(g,0)
	double precision intent(in,out),dimension(n,n),depend(n) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision intent(out),dimension(2*n,2*n),depend(n) :: u
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	integer intent(out) :: info
	double precision intent(out):: rcond
	double precision intent(out),dimension(2*n),depend(n) :: wr
	double precision intent(out),dimension(2*n),depend(n) :: wi
	double precision intent(out),dimension(2*n,2*n),depend(n) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	integer intent(hide,cache),dimension(2*n),depend(n) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional,check(ldwork>=max(3,6*n)),depend(n) :: ldwork=max(3,6*n)
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
end subroutine sb02md
!
! wrappers for sb02od
!
subroutine sb02od_n(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'N'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer intent(hide) :: p=0 ! this is not needed as fact = 'N' 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(n,n),depend(n) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(m,m),depend(m) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n+m) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_n
subroutine sb02od_c(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'C'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer required,check(p>0) :: p 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(p,n),depend(n,p) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(m,m),depend(m) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n+m) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_c
subroutine sb02od_d(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'D'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer required,check(p>0) :: p 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(n,n),depend(n) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(p,m),depend(m,p) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n+m) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_d
subroutine sb02od_b(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'B'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer required,check(p>0) :: p 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(p,n),depend(n,p) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(p,m),depend(m,p) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n+m) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_b
!
! routines for sb02mt
!
subroutine sb02mt_n(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'Z'
    character intent(hide) :: fact = 'N'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(out),dimension(1,1) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out),dimension(1,1) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(out),dimension(1,1) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(m),depend(m) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer :: ldwork = max(3,n)*m+2
    integer intent(out) :: info
end subroutine sb02mt_n
subroutine sb02mt_c(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'Z'
    character intent(hide) :: fact = 'C'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(out),dimension(1,1) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out),dimension(1,1) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(out),dimension(1,1) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(1) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer intent(hide) :: ldwork = 1
    integer intent(out) :: info
end subroutine sb02mt_c
subroutine sb02mt_nl(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'N'
    character intent(hide) :: fact = 'N'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(m),depend(m) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer :: ldwork = max(3,n)*m+2
    integer intent(out) :: info
end subroutine sb02mt_nl
subroutine sb02mt_cl(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'N'
    character intent(hide) :: fact = 'C'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(1) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer intent(hide) :: ldwork = 1
    integer intent(out) :: info
end subroutine sb02mt_cl
subroutine sb03md(dico,job,fact,trana,n,a,lda,u,ldu,c,ldc,scale,sep,ferr,wr,wi,iwork,dwork,ldwork,info) ! in :new:SB03MD.f
    fortranname sb03md
    character :: dico
    character :: job='X'
    character :: fact='N'
    character :: trana='N'
    integer check(n>0) :: n
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision  intent(in,out,copy),dimension(n,n),depend(n) :: u
    integer intent(hide),depend(u) :: ldu=shape(u,0)
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: c
    integer intent(hide),depend(c) :: ldc=shape(c,0)
    double precision intent(out) :: scale
    double precision intent(out) :: sep
    double precision intent(out) :: ferr
    double precision intent(out),dimension(n),depend(n) :: wr
    double precision intent(out),dimension(n),depend(n) :: wi
    integer intent(hide,cache),dimension(n*n),depend(n) :: iwork
    double precision intent(hide,cache),dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(2*n*n,3*n)),depend(n) :: ldwork=max(2*n*n,3*n)
    integer intent(out) :: info
end subroutine sb03md
subroutine sb03od(dico,fact,trans,n,m,a,lda,q,ldq,b,ldb,scale,wr,wi,dwork,ldwork,info) ! in SB03OD.f
    fortranname sb03od
    character :: dico
    character :: fact='N'
    character :: trans='N'
    integer check(n>0) :: n
    integer check(m>0) :: m
    double precision dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out) :: scale
    double precision intent(out),dimension(n),depend(n) :: wr
    double precision intent(out),dimension(n),depend(n) :: wi
    double precision intent(hide,cache),dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(1,4*n + min(m,n))),depend(n,m) :: ldwork=max(1,4*n + min(m,n))
    integer intent(out) :: info    
end subroutine sb03od
subroutine sb04md(n,m,a,lda,b,ldb,c,ldc,z,ldz,iwork,dwork,ldwork,info) ! in SB04MD.f
    integer check(n>0) :: n
    integer check(m>0) :: m
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: c
    integer intent(hide),depend(c) :: ldc=shape(c,0)
    double precision intent(out),dimension(m,m),depend(m) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    integer intent(hide,cache),dimension(4*n),depend(n) :: iwork
    double precision intent(hide,cache),dimension(ldwork) :: dwork
    integer optional,depend(n,m) :: ldwork = max(2*n*n+8*n,max(5*m,n+m))
    integer intent(out) :: info
end subroutine sb04md
subroutine sb04qd(n,m,a,lda,b,ldb,c,ldc,z,ldz,iwork,dwork,ldwork,info) ! in SB04QD.f
     fortranname sb04qd
     integer check(n>0) :: n
     integer check(m>0) :: m
     double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
     integer intent(hide),depend(a) :: lda=shape(a,0)
     double precision intent(in,out,copy),dimension(m,m),depend(m) :: b
     integer intent(hide),depend(b) :: ldb=shape(b,0)
     double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: c
     integer intent(hide),depend(c) :: ldc=shape(c,0)
     double precision intent(out),dimension(m,m),depend(m) :: z
     integer intent(hide),depend(z) :: ldz=shape(z,0)
     integer intent(hide,cache),dimension(4*n),depend(n) :: iwork
     double precision intent(hide,cache),dimension(ldwork) :: dwork
     integer optional,depend(n,m) :: ldwork = max(2*n*n+9*n,max(5*m,n+m))
     integer intent(out) :: info
end subroutine sb04qd
subroutine sb10ad(job,n,m,np,ncon,nmeas,gamma,a,lda,b,ldb,c,ldc,d,ldd,ak,ldak,bk,ldbk,ck,ldck,dk,lddk,ac,ldac,bc,ldbc,cc,ldcc,dc,lddc,rcond,gtol,actol,iwork,liwork,dwork,ldwork,bwork,lbwork,info) ! in :python-control:SB10AD.f
    integer :: job
    integer check(n>0) :: n
    integer check(m>0) :: m
    integer check(np>0) :: np
    integer check(ncon>=0) :: ncon
    ! the following check togheter with ncon>=0 should guarantee the following:
    ! m>=ncon
    ! np>=nmeas
    ! m-ncon>=nmeas
    ! np-nmeas>=ncon
    integer check(nmeas>=0 && nmeas<=min(m,np)-ncon), depend(m,np,ncon) :: nmeas
    double precision intent(in,out) :: gamma            
    double precision dimension(n,n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(n,m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(np,n), depend(np,n) :: c
    integer intent(hide), depend(c) :: ldc=shape(c,0)
    double precision dimension(np,m), depend(np,m) :: d
    integer intent(hide), depend(d) :: ldd=shape(d,0)
    double precision intent(out), dimension(n,n), depend(n) :: ak
    integer intent(hide), depend(ak) :: ldak=shape(ak,0)
    double precision intent(out), dimension(n,nmeas), depend(n,nmeas) :: bk
    integer intent(hide), depend(bk) :: ldbk=shape(bk,0)
    double precision intent(out), dimension(ncon,n), depend(ncon,n) :: ck
    integer intent(hide), depend(ck) :: ldck=shape(ck,0)
    double precision intent(out), dimension(ncon,nmeas), depend(ncon,nmeas) :: dk
    integer intent(hide), depend(dk) :: lddk=shape(dk,0)
    double precision intent(out), dimension(2*n,2*n), depend(n) :: ac
    integer intent(hide), depend(ac) :: ldac=shape(ac,0)
    double precision intent(out), dimension(2*n,m-ncon), depend(n,m,ncon) :: bc
    integer intent(hide), depend(bc) :: ldbc=shape(bc,0)
    double precision intent(out), dimension(np-nmeas,2*n), depend(np,nmeas,n) :: cc
    integer intent(hide), depend(cc) :: ldcc=shape(cc,0)
    double precision intent(out), dimension(np-nmeas,m-ncon), depend(np,nmeas,m,ncon) :: dc
    integer intent(hide), depend(dc) :: lddc=shape(dc,0)
    double precision intent(out), dimension(4) :: rcond
    double precision optional :: gtol=0.0
    double precision optional :: actol=0.0
    integer intent(hide), dimension(liwork), depend(liwork) :: iwork
    integer optional :: liwork
    double precision intent(hide), dimension(ldwork), depend(ldwork) :: dwork
    integer optional :: ldwork
    logical intent(hide), dimension(lbwork), depend(lbwork) :: bwork
    integer intent(hide), depend(n):: lbwork=2*n
    integer intent(out) :: info
end subroutine sb10ad
subroutine sb10dd(n,m,np,ncon,nmeas,gamma,a,lda,b,ldb,c,ldc,d,ldd,ak,ldak,bk,ldbk,ck,ldck,dk,lddk,x,ldx,z,ldz,rcond,tol,iwork,dwork,ldwork,bwork,info) ! in :python-control:SB10DD.f
    integer check(n>0) :: n
    integer check(m>0) :: m
    integer check(np>0) :: np
    integer check(ncon>=0) :: ncon
    ! the following check togheter with ncon>=0 should guarantee the following:
    ! m>=ncon
    ! np>=nmeas
    ! m-ncon>=nmeas
    ! np-nmeas>=ncon
    integer check(nmeas>=0 && nmeas<=min(m,np)-ncon), depend(m,np,ncon) :: nmeas
    double precision intent(in,out) :: gamma            
    double precision dimension(n,n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(n,m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(np,n), depend(np,n) :: c
    integer intent(hide), depend(c) :: ldc=shape(c,0)
    double precision dimension(np,m), depend(np,m) :: d
    integer intent(hide), depend(d) :: ldd=shape(d,0)
    double precision intent(out), dimension(n,n), depend(n) :: ak
    integer intent(hide), depend(ak) :: ldak=shape(ak,0)
    double precision intent(out), dimension(n,nmeas), depend(n,nmeas) :: bk
    integer intent(hide), depend(bk) :: ldbk=shape(bk,0)
    double precision intent(out), dimension(ncon,n), depend(ncon,n) :: ck
    integer intent(hide), depend(ck) :: ldck=shape(ck,0)
    double precision intent(out), dimension(ncon,nmeas), depend(ncon,nmeas) :: dk
    integer intent(hide), depend(dk) :: lddk=shape(dk,0)
    double precision intent(out), dimension(n,n), depend(n) :: x
    integer intent(hide), depend(x) :: ldx=shape(x,0)
    double precision intent(out), dimension(n,n), depend(n) :: z
    integer intent(hide), depend(z) :: ldz=shape(z,0)
    double precision intent(out), dimension(8) :: rcond
    double precision optional :: tol=0.0
    ! integer intent(hide,cache), dimension(max(2*max(m,n),max(m,max(m+np,n*n)))), depend(n,m,np,ncon,nmeas) :: iwork
    integer intent(hide), dimension(max(2*max(max(max(max(n,m-ncon),np-nmeas),ncon),nmeas),n*n)), depend(n,m,np,ncon,nmeas) :: iwork
    double precision intent(hide,cache), dimension(ldwork), depend(ldwork) :: dwork
    integer optional :: ldwork
    logical intent(hide,cache), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: info
end subroutine sb10dd
subroutine sb10fd(n,m,np,ncon,nmeas,gamma,a,lda,b,ldb,c,ldc,d,ldd,ak,ldak,bk,ldbk,ck,ldck,dk,lddk,rcond,tol,iwork,dwork,ldwork,bwork,info) ! in SB10FD.f
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(np>=0) :: np
    integer intent(in),check(m>=ncon && ncon>=0 && np-nmeas>=ncon),depend(m,ncon):: ncon
    integer intent(in),check(np>=nmeas && nmeas>=0 && m-ncon>=nmeas),depend(np,ncon):: nmeas
    double precision intent(in),check(gamma>=0.0) :: gamma
    double precision intent(in),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in),dimension(np,n),depend(np,n) :: c
    integer intent(hide),depend(c) :: ldc=shape(c,0)
    double precision intent(in),dimension(np,m),depend(np,m) :: d
    integer intent(hide),depend(d) :: ldd=shape(d,0)
    double precision intent(out),dimension(n,n) :: ak
    integer intent(hide),depend(ak) :: ldak=shape(ak,0)
    double precision intent(out),dimension(n,nmeas) :: bk
    integer intent(hide),depend(bk) :: ldbk=shape(bk,0)
    double precision intent(out),dimension(ncon,n) :: ck
    integer intent(hide),depend(ck) :: ldck=shape(ck,0)
    double precision intent(out),dimension(ncon,nmeas) :: dk
    integer intent(hide),depend(dk) :: lddk=shape(dk,0)
    double precision intent(out),dimension(4) :: rcond
    double precision intent(in) :: tol
    integer intent(hide,cache),dimension(max(2*max(n,m-ncon),2*max(np-nmeas,ncon)),n*n),depend(n,m,ncon,np,nmeas) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer intent(in) :: ldwork
    logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
    integer intent(out) :: info
end subroutine sb10fd
subroutine sb10hd(n,m,np,ncon,nmeas,a,lda,b,ldb,c,ldc,d,ldd,ak,ldak,bk,ldbk,ck,ldck,dk,lddk,rcond,tol,iwork,dwork,ldwork,bwork,info) ! in :python-control:SB10HD.f
    integer check(n>0) :: n
    integer check(m>0) :: m
    integer check(np>0) :: np
    integer check(ncon>=0) :: ncon
    ! the following check togheter with ncon>=0 should guarantee the following:
    ! m>=ncon
    ! np>=nmeas
    ! m-ncon>=nmeas
    ! np-nmeas>=ncon
    integer check(nmeas>=0 && nmeas<=min(m,np)-ncon), depend(m,np,ncon) :: nmeas
    double precision dimension(n,n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(n,m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(np,n), depend(np,n) :: c
    integer intent(hide), depend(c) :: ldc=shape(c,0)
    double precision dimension(np,m), depend(np,m) :: d
    integer intent(hide), depend(d) :: ldd=shape(d,0)
    double precision intent(out), dimension(n,n), depend(n) :: ak
    integer intent(hide), depend(ak) :: ldak=shape(ak,0)
    double precision intent(out), dimension(n,nmeas), depend(n,nmeas) :: bk
    integer intent(hide), depend(bk) :: ldbk=shape(bk,0)
    double precision intent(out), dimension(ncon,n), depend(ncon,n) :: ck
    integer intent(hide), depend(ck) :: ldck=shape(ck,0)
    double precision intent(out), dimension(ncon,nmeas), depend(ncon,nmeas) :: dk
    integer intent(hide), depend(dk) :: lddk=shape(dk,0)
    double precision intent(out), dimension(4) :: rcond
    double precision optional:: tol=0.0
    integer intent(hide), dimension(max(2*n,n*n)), depend(n) :: iwork
    double precision intent(hide), dimension(ldwork), depend(ldwork) :: dwork
    integer optional:: ldwork
    logical intent(hide), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: info
end subroutine sb10hd
subroutine sb10jd(n,m,np,a,lda,b,ldb,c,ldc,d,ldd,e,lde,nsys,dwork,ldwork,info) ! in SB10JD.f
    integer intent(in),required :: n
    integer intent(in),required :: m
    integer intent(in),required :: np
    double precision intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    double precision intent(in,out,copy),dimension(ldb,m) :: b
    integer intent(hide),depend(b) :: ldb=MAX(shape(b,0),1)
    double precision intent(in,out,copy),dimension(ldc,n) :: c
    integer intent(hide),depend(c) :: ldc=MAX(shape(c,0),1)
    double precision intent(in,out,copy),dimension(ldd,m) :: d
    integer intent(hide),depend(d) :: ldd=MAX(shape(d,0),1)
    double precision intent(in,copy),dimension(lde,n) :: e
    integer intent(hide),depend(e) :: lde=MAX(shape(e,0),1)
    integer intent(out) :: nsys
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
integer required intent(in) :: ldwork
    integer intent(out) :: info
end subroutine sb10jd
subroutine sg03ad(dico,job,fact,trans,uplo,n,a,lda,e,lde,q,ldq,z,ldz,x,ldx,scale,sep,ferr,alphar,alphai,beta,iwork,dwork,ldwork,info) ! in SG03AD.f
    character :: dico
    character :: job
    character :: fact
    character :: trans
    character :: uplo
    integer check(n>=0) :: n
    double precision intent(in,out), dimension(n,n), depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out), dimension(n,n), depend(n) :: e
    integer intent(hide),depend(e) :: lde=shape(e,0)
    double precision intent(in,out), dimension(n,n), depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out), dimension(n,n), depend(n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    double precision intent(in,out), dimension(n,n), depend(n) :: x
    integer intent(hide),depend(x) :: ldx=shape(x,0)
    double precision intent(out) :: scale
    double precision intent(out) :: sep
    double precision intent(out) :: ferr
    double precision intent(out), dimension(n), depend(n) :: alphar
    double precision intent(out), dimension(n), depend(n) :: alphai
    double precision intent(out), dimension(n), depend(n) :: beta
    integer intent(hide,cache),dimension(n*n),depend(n) :: iwork
    double precision intent(hide,cache),dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(1,max(2*n*n,8*n+16))),depend(n) :: ldwork=max(1,max(2*n*n,8*n+16))
    integer intent(out) :: info
end subroutine sg03ad
subroutine sg02ad_g(dico,jobb,fact,uplo,jobl,scal,sort,acc,n,m,p,a,lda,e,lde,b,ldb,q,ldq,r,ldr,l,ldl,rcondu,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,iwarn,info) ! in SG02AD.f
    fortranname sg02ad
    character :: dico
    character intent(hide) :: jobb = 'G'
    character intent(hide) :: fact = 'N' !  Unused for jobb = 'G'
    character :: uplo
    character intent(hide) :: jobl = 'Z' ! Unused for jobb = 'G'
    character intent(hide) :: scal = 'N' ! Unused for jobb = 'G'
    character :: sort
    character :: acc
    integer intent(input), (check n>=0) :: n
    integer intent(hide), (check m>=0) :: m = 0 !  Unused for jobb = 'G'
    integer intent(hide) :: p = 0 ! Unused for jobb = 'G''
    double precision dimension(max(1,n),n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(max(1,n),n), depend(n) :: e
    integer intent(hide), depend(e) :: lde=shape(e,0)
    double precision dimension(max(1,n),n), depend(n) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(max(1,n),n), depend(n) :: q
    integer intent(hide), depend(q) :: ldq=shape(q,0)
    double precision intent(hide), dimension(1,1) :: r ! Unused for jobb = 'G'
    integer intent(hide), depend(r) :: ldr=shape(r,0)
    double precision intent(hide), dimension(1,1) :: l  ! Unused for jobb = 'G'
    integer intent(hide), depend(l) :: ldl=shape(l,0)  ! Unused for jobb = 'G'
    double precision intent(out) :: rcondu
    double precision intent(out), dimension(max(1,n),n), depend(n) :: x
    integer intent(hide), depend(x) :: ldx=shape(x,0)
    double precision intent(out), dimension(2*n), depend(n) :: alfar
    double precision intent(out), dimension(2*n), depend(n) :: alfai
    double precision intent(out), dimension(2*n), depend(n) :: beta
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: s
    integer intent(hide), depend(s) :: lds=shape(s,0)
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: t
    integer intent(hide), depend(t) :: ldt=shape(t,0)
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: u
    integer intent(hide), depend(u) :: ldu=shape(u,0)
    double precision intent(hide) :: tol = 0 ! Unused for jobb = 'G'
    integer intent(hide,cache), dimension(2*n), depend(n) :: iwork ! Since jobb = 'G'
    double precision intent(hide,cache), dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(7*(2*n+1)+16,max(16*n,8*n+16))),depend(n) :: ldwork=max(7*(2*n+1)+16,max(16*n,8*n+16))
    logical intent(hide,cache), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sg02ad_g
subroutine sg02ad_bn(dico,jobb,fact,uplo,jobl,scal,sort,acc,n,m,p,a,lda,e,lde,b,ldb,q,ldq,r,ldr,l,ldl,rcondu,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,iwarn,info) ! in SG02AD.f
    fortranname sg02ad
    character :: dico
    character intent(hide) :: jobb = 'B'
    character intent(hide) :: fact = 'N'
    character :: uplo
    character :: jobl
    character :: scal
    character :: sort
    character :: acc
    integer (check n>=0) :: n
    integer (check m>=0) :: m
    integer intent(hide) :: p = 0 ! Unused for fact = 'N'
    double precision dimension(max(1,n),n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(max(1,n),n), depend(n) :: e
    integer intent(hide), depend(e) :: lde=shape(e,0)
    double precision dimension(max(1,n),m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(max(1,n),n), depend(n) :: q
    integer intent(hide), depend(q) :: ldq=shape(q,0)
    double precision dimension(max(1,m),m), depend(m) :: r ! fact = 'N'
    integer intent(hide), depend(r) :: ldr=shape(r,0)
    double precision dimension(max(1,n),m), depend(n,m) :: l  ! It would be nicer to not force the dimension here when not used
    integer intent(hide), depend(l) :: ldl=shape(l,0)
    double precision intent(out) :: rcondu
    double precision intent(out), dimension(max(1,n),n), depend(n) :: x
    integer intent(hide), depend(x) :: ldx=shape(x,0)
    double precision intent(out), dimension(2*n), depend(n) :: alfar
    double precision intent(out), dimension(2*n), depend(n) :: alfai
    double precision intent(out), dimension(2*n), depend(n) :: beta
    double precision intent(out), dimension(max(1,2*n+m),2*n+m), depend(n,m) :: s
    integer intent(hide), depend(s) :: lds=shape(s,0)
    double precision intent(out), dimension(max(1,2*n+m),2*n), depend(n,m) :: t
    integer intent(hide), depend(t) :: ldt=shape(t,0)
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: u
    integer intent(hide), depend(u) :: ldu=shape(u,0)
    double precision optional :: tol = -1
    integer intent(hide,cache), dimension(max(m,2*n)), depend(n,m) :: iwork ! Since jobb = 'B'
    double precision intent(hide,cache), dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))),depend(n,m) :: ldwork=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))
    logical intent(hide,cache), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sg02ad_bn
subroutine sg02ad_bc(dico,jobb,fact,uplo,jobl,scal,sort,acc,n,m,p,a,lda,e,lde,b,ldb,q,ldq,r,ldr,l,ldl,rcondu,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,iwarn,info) ! in SG02AD.f
    fortranname sg02ad
    character :: dico
    character intent(hide) :: jobb = 'B'
    character intent(hide) :: fact = 'C'
    character intent(hide) :: uplo = 'U' ! Unsused for fact = 'C','D' and 'B'
    character :: jobl
    character :: scal
    character :: sort
    character :: acc
    integer (check n>=0) :: n
    integer (check m>=0) :: m
    integer (check p>=0) :: p
    double precision dimension(max(1,n),n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(max(1,n),n), depend(n) :: e
    integer intent(hide), depend(e) :: lde=shape(e,0)
    double precision dimension(max(1,n),m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(max(1,p),n), depend(p,n) :: q ! fact = 'C'
    integer intent(hide), depend(q) :: ldq=shape(q,0)
    double precision dimension(max(1,m),m), depend(m) :: r ! fact = 'C'
    integer intent(hide), depend(r) :: ldr=shape(r,0)
    double precision dimension(max(1,n),m), depend(n,m) :: l  ! It would be nicer to not force the dimension here when not used
    integer intent(hide), depend(l) :: ldl=shape(l,0)
    double precision intent(out) :: rcondu
    double precision intent(out), dimension(n,n), depend(n) :: x
    integer intent(hide), depend(x) :: ldx=shape(x,0)
    double precision intent(out), dimension(2*n), depend(n) :: alfar
    double precision intent(out), dimension(2*n), depend(n) :: alfai
    double precision intent(out), dimension(2*n), depend(n) :: beta
    double precision intent(out), dimension(max(1,2*n+m),2*n+m), depend(n,m) :: s
    integer intent(hide), depend(s) :: lds=shape(s,0)
    double precision intent(out), dimension(max(1,2*n+m),2*n), depend(n,m) :: t
    integer intent(hide), depend(t) :: ldt=shape(t,0)
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: u
    integer intent(hide), depend(u) :: ldu=shape(u,0)
    double precision optional :: tol = -1
    integer intent(hide,cache), dimension(max(m,2*n)), depend(n,m) :: iwork ! Since jobb = 'B'
    double precision intent(hide,cache), dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))),depend(n,m) :: ldwork=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))
    logical intent(hide,cache), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sg02ad_bc
subroutine sg02ad_bd(dico,jobb,fact,uplo,jobl,scal,sort,acc,n,m,p,a,lda,e,lde,b,ldb,q,ldq,r,ldr,l,ldl,rcondu,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,iwarn,info) ! in SG02AD.f
    fortranname sg02ad
    character :: dico
    character intent(hide) :: jobb = 'B'
    character intent(hide) :: fact = 'D'
    character intent(hide) :: uplo = 'U' ! Unsused for fact = 'C','D' and 'B'
    character :: jobl
    character :: scal
    character :: sort
    character :: acc
    integer (check n>=0) :: n
    integer (check m>=0) :: m
    integer (check p>=0) :: p
    double precision dimension(max(1,n),n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(max(1,n),n), depend(n) :: e
    integer intent(hide), depend(e) :: lde=shape(e,0)
    double precision dimension(max(1,n),m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(max(1,n),n), depend(n) :: q ! fact = 'D'
    integer intent(hide), depend(q) :: ldq=shape(q,0)
    double precision dimension(max(1,p),m), depend(p,m) :: r ! fact = 'D'
    integer intent(hide), depend(r) :: ldr=shape(r,0)
    double precision dimension(max(1,n),m), depend(n,m) :: l  ! It would be nicer to not force the dimension here when not used
    integer intent(hide), depend(l) :: ldl=shape(l,0)
    double precision intent(out) :: rcondu
    double precision intent(out), dimension(n,n), depend(n) :: x
    integer intent(hide), depend(x) :: ldx=shape(x,0)
    double precision intent(out), dimension(2*n), depend(n) :: alfar
    double precision intent(out), dimension(2*n), depend(n) :: alfai
    double precision intent(out), dimension(2*n), depend(n) :: beta
    double precision intent(out), dimension(max(1,2*n+m),2*n+m), depend(n,m) :: s
    integer intent(hide), depend(s) :: lds=shape(s,0)
    double precision intent(out), dimension(max(1,2*n+m),2*n), depend(n,m) :: t
    integer intent(hide), depend(t) :: ldt=shape(t,0)
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: u
    integer intent(hide), depend(u) :: ldu=shape(u,0)
    double precision optional :: tol = -1
    integer intent(hide,cache), dimension(max(m,2*n)), depend(n,m) :: iwork ! Since jobb = 'B'
    double precision intent(hide,cache), dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))),depend(n,m) :: ldwork=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))
    logical intent(hide,cache), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sg02ad_bd
subroutine sg02ad_bb(dico,jobb,fact,uplo,jobl,scal,sort,acc,n,m,p,a,lda,e,lde,b,ldb,q,ldq,r,ldr,l,ldl,rcondu,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,iwarn,info) ! in SG02AD.f
    fortranname sg02ad
    character :: dico
    character intent(hide) :: jobb = 'B'
    character intent(hide) :: fact = 'B'
    character intent(hide) :: uplo = 'U' ! Unsused for fact = 'C','D' and 'B'
    character :: jobl
    character :: scal
    character :: sort
    character :: acc
    integer (check n>=0) :: n
    integer (check m>=0) :: m
    integer (check p>=0) :: p
    double precision dimension(max(1,n),n), depend(n) :: a
    integer intent(hide), depend(a) :: lda=shape(a,0)
    double precision dimension(max(1,n),n), depend(n) :: e
    integer intent(hide), depend(e) :: lde=shape(e,0)
    double precision dimension(max(1,n),m), depend(n,m) :: b
    integer intent(hide), depend(b) :: ldb=shape(b,0)
    double precision dimension(max(1,p),n), depend(p,n) :: q ! fact = 'B'
    integer intent(hide), depend(q) :: ldq=shape(q,0)
    double precision dimension(max(1,p),m), depend(p,m) :: r ! fact = 'B'
    integer intent(hide), depend(r) :: ldr=shape(r,0)
    double precision dimension(max(1,n),m), depend(n,m) :: l  ! It would be nicer to not force the dimension here when not used
    integer intent(hide), depend(l) :: ldl=shape(l,0)
    double precision intent(out) :: rcondu
    double precision intent(out), dimension(n,n), depend(n) :: x
    integer intent(hide), depend(x) :: ldx=shape(x,0)
    double precision intent(out), dimension(2*n), depend(n) :: alfar
    double precision intent(out), dimension(2*n), depend(n) :: alfai
    double precision intent(out), dimension(2*n), depend(n) :: beta
    double precision intent(out), dimension(max(1,2*n+m),2*n+m), depend(n,m) :: s
    integer intent(hide), depend(s) :: lds=shape(s,0)
    double precision intent(out), dimension(max(1,2*n+m),2*n), depend(n,m) :: t
    integer intent(hide), depend(t) :: ldt=shape(t,0)
    double precision intent(out), dimension(max(1,2*n),2*n), depend(n) :: u
    integer intent(hide), depend(u) :: ldu=shape(u,0)
    double precision optional :: tol = -1
    integer intent(hide,cache), dimension(max(m,2*n)), depend(n) :: iwork ! Since jobb = 'B'
    double precision intent(hide,cache), dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(16*n,8*n+16))))),depend(n,m) :: ldwork=max(3*m,max(2*n+m,max(7*(2*n+1)+16,max(8*n+16,16*n))))
    logical intent(hide,cache), dimension(2*n), depend(n) :: bwork
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sg02ad_bb
subroutine sg03bd(dico,fact,trans,n,m,a,lda,e,lde,q,ldq,z,ldz,b,ldb,scale,alphar,alphai,beta,dwork,ldwork,info) ! in SG03BD.f
    fortranname sg03bd
    character :: dico
    character :: fact='N'
    character :: trans='N'
    integer check(n>0) :: n
    integer check(m>0) :: m
    double precision dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision dimension(n,n),depend(n) :: e
    integer intent(hide),depend(e) :: lde=shape(e,0)
    double precision dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision dimension(n,n),depend(n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    double precision intent(in,out,copy),dimension(max(m,n),n),depend(m,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out) :: scale
    double precision intent(out),dimension(n),depend(n) :: alphar
    double precision intent(out),dimension(n),depend(n) :: alphai
    double precision intent(out),dimension(n),depend(n) :: beta
    double precision intent(hide,cache),dimension(ldwork) :: dwork
    integer optional,check(ldwork>=max(4*n,6*n-6)),depend(n,m) :: ldwork=max(4*n,6*n-6)
    integer intent(out) :: info    
end subroutine sg03bd
